buildscript {
	repositories {
		maven { url "https://repo.spring.io/plugins-release" }
	}
	dependencies {
		classpath("org.springframework.build.gradle:propdeps-plugin:0.0.7")
		classpath("org.asciidoctor:asciidoctor-gradle-plugin:1.5.3")
		classpath("io.spring.gradle:docbook-reference-plugin:0.3.1")
	}
}



ext {
	linkHomepage = 'https://projects.spring.io/spring-framework'
	linkCi = 'https://build.spring.io/browse/SPR'
	linkIssue = 'https://jira.spring.io/browse/SPR'
	linkScmUrl = 'https://github.com/spring-projects/spring-framework'
	linkScmConnection = 'scm:git:git://github.com/spring-projects/spring-framework.git'
	linkScmDevConnection = 'scm:git:ssh://git@github.com:spring-projects/spring-framework.git'

	moduleProjects = subprojects.findAll {
		!it.name.equals('spring-build-src') && !it.name.equals('spring-framework-bom')
	}
}

configure(allprojects) { project ->
	group = "org.springframework"
	version = qualifyVersionIfNecessary(version)

	ext.activationApiVersion   = "1.1.1"
	ext.annotationApiVersion   = "1.2"
	ext.aspectjVersion         = "1.9.0.BETA-5"
	ext.beanvalVersion         = "1.1.0.Final"
	ext.cacheApiVersion        = "1.0.0"
	ext.caffeineVersion        = "2.3.5"
	ext.eclipselinkVersion     = "2.6.4"
	ext.ehcacheVersion         = "2.10.3"
	ext.ehcachejcacheVersion   = "1.0.1"
	ext.ehcache3Version        = "3.1.3"
	ext.ejbApiVersion          = "3.2"
	ext.elApiVersion           = "3.0.1-b04"
	ext.fileuploadVersion      = "1.3.2"
	ext.freemarkerVersion      = "2.3.25-incubating"
	ext.groovyVersion          = "2.4.7"
	ext.gsonVersion            = "2.8.0"
	ext.hamcrestVersion        = "1.3"
	ext.hibernate5Version      = "5.2.4.Final"
	ext.hibval5Version         = "5.3.2.Final"
	ext.hsqldbVersion          = "2.3.4"
	ext.httpasyncVersion       = "4.1.2"
	ext.httpclientVersion      = "4.5.2"
	ext.interceptorApiVersion  = "1.2"
	ext.jackson2Version        = "2.8.5"
	ext.javamailVersion        = "1.5.6"
	ext.jaxbVersion            = "2.2.11"
	ext.jaxwsVersion           = "2.2.11"
	ext.jcaVersion             = "1.7"
	ext.jettyVersion           = "9.4.0.RC1"  // RC2 has broken HEAD handling
	ext.jmsVersion             = "2.0.1"
	ext.jodaVersion            = "2.9.6"
	ext.jpaVersion             = "2.1.1"
	ext.jsfVersion             = "2.2"
	ext.jspVersion             = "2.3.2-b02"
	ext.jtaVersion             = "1.2"
	ext.junitVersion           = "4.12"
	ext.junitJupiterVersion    = '5.0.0-M2'
	ext.junitPlatformVersion   = '1.0.0-M2'
	ext.log4jVersion           = '2.7'
	ext.nettyVersion           = "4.1.6.Final"
	ext.okhttpVersion          = "2.7.5"
	ext.okhttp3Version         = "3.4.2"
	ext.poiVersion             = "3.15"
	ext.protobufVersion        = "3.1.0"
	ext.quartzVersion          = "2.2.3"
	ext.reactivestreamsVersion = "1.0.0"
	ext.reactorVersion         = "2.0.8.RELEASE"
	ext.reactorCoreVersion     = '3.0.3.RELEASE'
	ext.reactorNettyVersion    = '0.5.2.RELEASE'
	ext.romeVersion            = "1.7.0"
	ext.rxjavaVersion          = '1.2.2'
	ext.rxjavaAdapterVersion   = '1.2.1'
	ext.rxjava2Version         = '2.0.1'
	ext.rxnettyVersion         = '0.5.2-rc.5'
	ext.servletVersion         = "3.1.0"
	ext.slf4jVersion           = "1.7.21"
	ext.snakeyamlVersion       = "1.17"
	ext.snifferVersion         = "1.15"
	ext.testngVersion          = "6.9.12"
	ext.tiles3Version          = "3.0.7"
	ext.tomcatVersion          = "8.5.8"
	ext.tyrusVersion           = "1.13"
	ext.undertowVersion        = "1.4.4.Final"
	ext.websocketVersion       = "1.1"
	ext.woodstoxVersion        = "5.0.3"
	ext.xmlunitVersion         = "2.2.1"
	ext.xnioVersion            = "3.4.1.Final"
	ext.xstreamVersion         = "1.4.9"

	ext.gradleScriptDir = "${rootProject.projectDir}/gradle"

	apply plugin: "propdeps"
	apply plugin: "java"
	apply from: "${gradleScriptDir}/ide.gradle"

	configurations {
		sniffer
		javaApiSignature
	}

	configurations.all {
		// check for updates every build
		resolutionStrategy.cacheChangingModulesFor 0, 'seconds'

		// consistent netty version (e.g. clashes between netty-all vs netty-common)
		resolutionStrategy.eachDependency { DependencyResolveDetails details ->
			if (details.requested.group == 'io.netty') {
				details.useVersion nettyVersion
			}
		}
		resolutionStrategy.eachDependency { DependencyResolveDetails details ->
			if (details.requested.name == 'reactor-core' && details.requested.version.startsWith('3.')) {
				details.useVersion reactorCoreVersion
			}
		}
	}

	compileJava.options*.compilerArgs = [
		"-Xlint:serial", "-Xlint:varargs", "-Xlint:cast", "-Xlint:classfile",
		"-Xlint:dep-ann", "-Xlint:divzero", "-Xlint:empty", "-Xlint:finally",
		"-Xlint:overrides", "-Xlint:path", "-Xlint:processing", "-Xlint:static",
		"-Xlint:try", "-Xlint:fallthrough", "-Xlint:rawtypes", "-Xlint:deprecation",
		"-Xlint:unchecked", "-Xlint:-options", "-Werror"
	]

	compileTestJava.options*.compilerArgs = [
		"-Xlint:serial", "-Xlint:-varargs", "-Xlint:cast", "-Xlint:classfile",
		"-Xlint:dep-ann", "-Xlint:divzero", "-Xlint:empty", "-Xlint:finally",
		"-Xlint:overrides", "-Xlint:path", "-Xlint:processing", "-Xlint:static",
		"-Xlint:try", "-Xlint:-fallthrough", "-Xlint:-rawtypes", "-Xlint:-deprecation",
		"-Xlint:-unchecked", "-Xlint:-options"]

	compileJava {
		sourceCompatibility = 1.8
		targetCompatibility = 1.8
		options.encoding = 'UTF-8'
	}

	compileTestJava {
		sourceCompatibility = 1.8
		targetCompatibility = 1.8
		options.encoding = 'UTF-8'
		options.compilerArgs += "-parameters"
	}

	test {
		systemProperty("java.awt.headless", "true")
		systemProperty("testGroups", project.properties.get("testGroups"))
		scanForTestClasses = false
		include(["**/*Tests.class", "**/*Test.class"])
		// Since we set scanForTestClasses to false, we need to filter out inner
		// classes with the "$" pattern; otherwise, using -Dtest.single=MyTests to
		// run MyTests by itself will fail if MyTests contains any inner classes.
		exclude(["**/Abstract*.class", '**/*$*'])
		reports.junitXml.destination = file("$buildDir/test-results")
	}

	repositories {
		maven { url "https://repo.spring.io/libs-release" }
		maven { url "https://repo.spring.io/milestone" }
	}

	dependencies {
		testCompile("junit:junit:${junitVersion}") {
			exclude group:'org.hamcrest', module:'hamcrest-core'
		}
		testCompile("org.mockito:mockito-core:2.2.11") {
			exclude group:'org.hamcrest', module:'hamcrest-core'
		}
		testCompile("org.hamcrest:hamcrest-all:${hamcrestVersion}")
		testRuntime("org.apache.logging.log4j:log4j-core:${log4jVersion}")
		testRuntime("org.apache.logging.log4j:log4j-jcl:${log4jVersion}")

		sniffer("org.codehaus.mojo:animal-sniffer-ant-tasks:${snifferVersion}")
		javaApiSignature("org.codehaus.mojo.signature:java18:1.0@signature")
	}

	task copyJavaApiSignature(type: Copy) {
		ext.to = file("$buildDir/javaApiSignature/")
		description "Copy the resolved Animal Sniffer signature dependency artifact to a known location and name"
		from configurations.javaApiSignature
		into to
		rename '.*signature', 'javaApi.signature'
	}

	task sniff {
		group = "Verification"
		description = "Checks the Java API signatures"

		dependsOn compileJava
		dependsOn copyJavaApiSignature

		inputs.dir sourceSets.main.output.classesDir
		inputs.dir copyJavaApiSignature.to

		doLast {
			ant.taskdef(
				name: 'animalSniffer',
				classname: 'org.codehaus.mojo.animal_sniffer.ant.CheckSignatureTask',
				classpath: configurations.sniffer.asPath
			)

			// TODO: Animal Sniffer currently chokes on optional JDK 9 bytecode in AspectJ 1.9 beta 5
			// ant.animalSniffer(
			// 		signature: "$buildDir/javaApiSignature/javaApi.signature",
			// 		classpath: sourceSets.main.compileClasspath.asPath) {
			// 	path(path: sourceSets.main.output.classesDir)
			// 	annotation(className: "org.springframework.lang.UsesSunHttpServer")
			// }
		}
	}

	ext.javadocLinks = [
		"http://docs.oracle.com/javase/8/docs/api/",
		"http://docs.oracle.com/javaee/7/api/",
		"http://docs.oracle.com/cd/E13222_01/wls/docs90/javadocs/",  // CommonJ
		"http://pic.dhe.ibm.com/infocenter/wasinfo/v7r0/topic/com.ibm.websphere.javadoc.doc/web/apidocs/",
		"http://glassfish.java.net/nonav/docs/v3/api/",
		"http://docs.jboss.org/jbossas/javadoc/4.0.5/connector/",
		"http://docs.jboss.org/jbossas/javadoc/7.1.2.Final/",
		"http://tiles.apache.org/tiles-request/apidocs/",
		"http://tiles.apache.org/framework/apidocs/",
		"http://www.eclipse.org/aspectj/doc/released/aspectj5rt-api/",
		"http://ehcache.org/apidocs/${ehcacheVersion}",
		"http://ehcache.org/apidocs/${ehcache3Version}",
		"http://quartz-scheduler.org/api/2.2.1/",
		"http://fasterxml.github.io/jackson-core/javadoc/2.8/",
		"http://fasterxml.github.io/jackson-databind/javadoc/2.8/",
		"http://fasterxml.github.io/jackson-dataformat-xml/javadoc/2.8/",
		"http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/"
	] as String[]
}


configure(rootProject) {
	description = "Spring Framework"

	apply plugin: "org.asciidoctor.convert"
	apply plugin: "docbook-reference"
	apply plugin: "groovy"

	// apply plugin: "detect-split-packages"
	apply from: "${gradleScriptDir}/jdiff.gradle"

	asciidoctor {
		sourceDir project.file('src/asciidoc-zh')
		separateOutputDirs = false
		backends = ['docbook']
		options doctype: 'book', eruby: 'erubis'
		attributes 'spring-version': project.version, 'revnumber': project.version, 'docinfo': ""
	}

	reference {
		sourceDir = asciidoctor.outputDir
		pdfFilename = "spring-framework-reference-zh.pdf"
		epubFilename = "spring-framework-reference-zh.epub"
		expandPlaceholders = ""
	}


	
	
	afterEvaluate {
		tasks.findAll { it.name.startsWith("reference") }.each{ it.dependsOn.add("asciidoctor") }
		// tasks.findAll { it.name.startsWith("zh_reference") }.each{ it.dependsOn.add("zh_asciidoctor") }
	}

	// TODO: DetectSplitPackagesPlugin fails in line 154 due to method not found on java.io.File.
	// TODO: Possibly related to user rights or OS differences; passes on local Windows machine.
	// detectSplitPackages {
	//	projectsToScan -= project(":spring-instrument-tomcat")
	// }

	// don't publish the default jar for the root project
	configurations.archives.artifacts.clear()



	task api(type: Javadoc) {
		group = "Documentation"
		description = "Generates aggregated Javadoc API documentation."
		title = "${rootProject.description} ${version} API"

		dependsOn {
			subprojects.collect {
				it.tasks.getByName("jar")
			}
		}
		options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
		options.author = true
		options.header = rootProject.description
		options.overview = "src/api/overview.html"
		options.stylesheetFile = file("src/api/stylesheet.css")
		options.splitIndex = true
		options.links(project.ext.javadocLinks)
		options.addStringOption('Xdoclint:none', '-quiet')

		source subprojects.collect { project ->
			project.sourceSets.main.allJava
		}

		maxMemory = "1024m"
		destinationDir = new File(buildDir, "api")

		doFirst {
			classpath = files(
                // ensure Servlet 3.x has precedence on the javadoc classpath
                project(":spring-webmvc").sourceSets.main.compileClasspath.files.find { it =~ "servlet-api" },
				// ensure the javadoc process can resolve types compiled from .aj sources
				project(":spring-aspects").sourceSets.main.output
			)
			classpath += files(subprojects.collect { it.sourceSets.main.compileClasspath })
		}
	}

	task docsZip(type: Zip, dependsOn: 'reference') {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "docs"
		description = "Builds -${classifier} archive containing api and reference " +
			"for deployment at http://static.springframework.org/spring-framework/docs."

		from("src/dist") {
			include "changelog.txt"
		}

		from (api) {
			into "javadoc-api"
		}

		from (reference) {
			into "spring-framework-reference"
		}
	}

	task schemaZip(type: Zip) {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "schema"
		description = "Builds -${classifier} archive containing all " +
			"XSDs for deployment at http://springframework.org/schema."
		duplicatesStrategy 'exclude'
		moduleProjects.each { subproject ->
			def Properties schemas = new Properties();

			subproject.sourceSets.main.resources.find {
				it.path.endsWith("META-INF/spring.schemas")
			}?.withInputStream { schemas.load(it) }

			for (def key : schemas.keySet()) {
				def shortName = key.replaceAll(/http.*schema.(.*).spring-.*/, '$1')
				assert shortName != key
				File xsdFile = subproject.sourceSets.main.resources.find {
					it.path.endsWith(schemas.get(key))
				}
				assert xsdFile != null
				into (shortName) {
					from xsdFile.path
				}
			}
		}
	}

	task distZip(type: Zip, dependsOn: [docsZip, schemaZip]) {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "dist"
		description = "Builds -${classifier} archive, containing all jars and docs, " +
			"suitable for community download page."

		ext.baseDir = "${baseName}-${project.version}";

		from("src/dist") {
			include "readme.txt"
			include "license.txt"
			include "notice.txt"
			into "${baseDir}"
			expand(copyright: new Date().format("yyyy"), version: project.version)
		}

		from(zipTree(docsZip.archivePath)) {
			into "${baseDir}/docs"
		}

		from(zipTree(schemaZip.archivePath)) {
			into "${baseDir}/schema"
		}

		moduleProjects.each { subproject ->
			into ("${baseDir}/libs") {
				from subproject.jar
				if (subproject.tasks.findByPath("sourcesJar")) {
					from subproject.sourcesJar
				}
				if (subproject.tasks.findByPath("javadocJar")) {
					from subproject.javadocJar
				}
			}
		}
	}

	// Create a distribution that contains all dependencies (required and optional).
	// Not published by default; only for use when building from source.
	task depsZip(type: Zip, dependsOn: distZip) { zipTask ->
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "dist-with-deps"
		description = "Builds -${classifier} archive, containing everything " +
			"in the -${distZip.classifier} archive plus all runtime dependencies."

		from zipTree(distZip.archivePath)

		gradle.taskGraph.whenReady { taskGraph ->
			if (taskGraph.hasTask(":${zipTask.name}")) {
				def projectNames = rootProject.subprojects*.name
				def artifacts = new HashSet()
				subprojects.each { subproject ->
					(subproject.configurations.runtime.resolvedConfiguration.resolvedArtifacts +
					subproject.configurations.optional.resolvedConfiguration.resolvedArtifacts).each { artifact ->
						def dependency = artifact.moduleVersion.id
						if (!projectNames.contains(dependency.name)) {
							artifacts << artifact.file
						}
					}
				}

				zipTask.from(artifacts) {
					into "${distZip.baseDir}/deps"
				}
			}
		}
	}

	artifacts {
		archives docsZip
		archives schemaZip
		archives distZip
	}

	task wrapper(type: Wrapper) {
		description = "Generates gradlew[.bat] scripts"
		gradleVersion = '3.0'

		doLast() {
			def gradleOpts = "-XX:MaxMetaspaceSize=1024m -Xmx1024m"
			def gradleBatOpts = "$gradleOpts -XX:MaxHeapSize=256m"
			File wrapperFile = file("gradlew")
			wrapperFile.text = wrapperFile.text.replace("DEFAULT_JVM_OPTS=",
				"GRADLE_OPTS=\"$gradleOpts \$GRADLE_OPTS\"\nDEFAULT_JVM_OPTS=")
			File wrapperBatFile = file("gradlew.bat")
			wrapperBatFile.text = wrapperBatFile.text.replace("set DEFAULT_JVM_OPTS=",
				"set GRADLE_OPTS=$gradleBatOpts %GRADLE_OPTS%\nset DEFAULT_JVM_OPTS=")
		}
	}

}




/*
 * Support publication of artifacts versioned by topic branch.
 * CI builds supply `-P BRANCH_NAME=<TOPIC>` to gradle at build time.
 * If <TOPIC> starts with 'SPR-', change version
 *     from BUILD-SNAPSHOT => <TOPIC>-SNAPSHOT
 *     e.g. 3.2.1.BUILD-SNAPSHOT => 3.2.1.SPR-1234-SNAPSHOT
 */
def qualifyVersionIfNecessary(version) {
	if (rootProject.hasProperty("BRANCH_NAME")) {
		def qualifier = rootProject.getProperty("BRANCH_NAME")
		if (qualifier.startsWith("SPR-")) {
			return version.replace('BUILD', qualifier)
		}
	}
	return version
}
