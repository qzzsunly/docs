<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>23.&nbsp;Web Reactive Framework</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-web.html" title="Part&nbsp;V.&nbsp;The Web"><link rel="prev" href="websocket.html" title="22.&nbsp;WebSocket Support"><link rel="next" href="spring-integration.html" title="Part&nbsp;VI.&nbsp;Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">23.&nbsp;Web Reactive Framework</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="websocket.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;The Web</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="spring-integration.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="web-reactive" href="#web-reactive"></a>23.&nbsp;Web Reactive Framework</h2></div></div></div>

<p>This section provides basic information on the Spring Web Reactive support in Spring Framework 5.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-reactive-intro" href="#web-reactive-intro"></a>23.1&nbsp;Introduction</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-programming" href="#web-reactive-programming"></a>23.1.1&nbsp;Reactive Programming</h3></div></div></div>

<p>In plain terms reactive programming is about non-blocking applications that are asynchronous
and event-driven and require a small number of threads to scale. A key aspect of that
definition is the concept of backpressure which is a mechanism to ensure producers
don&#8217;t overwhelm consumers. For example in a pipeline of reactive components that extends
from the database to the HTTP socket when the HTTP client is slow the data
repository slows down or stops until capacity frees up.</p>
<p>From a programming model perspective reactive programming involves a major shift from imperative style logic
to a declarative composition of async logic. It is comparable to using <code class="literal">CompletableFuture</code> in Java 8
and composing follow-up actions via lambda expressions.</p>
<p>For a more extended introduction to reactive programming check the excellent multi-part series
<a class="ulink" href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape" target="_top">"Notes on Reactive Programming"</a>
by Dave Syer.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-api" href="#web-reactive-api"></a>23.1.2&nbsp;Spring Web Reactive Types</h3></div></div></div>

<p>Spring Framework 5 embraces
<a class="ulink" href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams" target="_top">Reactive Streams</a>
as the contract for communicating backpressure across async components and
libraries. Reactive Streams is a specification created through industry collaboration that
has also been adopted in Java 9 as <code class="literal">java.util.concurrent.Flow</code>.</p>
<p>The Spring Framework uses <a class="ulink" href="https://projectreactor.io/" target="_top">Reactor</a> internally for its own
reactive support. Reactor is a Reactive Streams implementation that further extends the
basic Reactive Streams <code class="literal">Publisher</code> contract with the <code class="literal">Flux</code> and <code class="literal">Mono</code> composable API
types to provide declarative operations on data sequences of <code class="literal">0..N</code> and <code class="literal">0..1</code>.</p>
<p>The Spring Framework exposes <code class="literal">Flux</code> and <code class="literal">Mono</code> in many of its own reactive APIs.
At the application level however, as always, Spring provides choice and fully supports
the use of RxJava. For more on reactive types check the post
<a class="ulink" href="https://spring.io/blog/2016/04/19/understanding-reactive-types" target="_top">"Understanding Reactive Types"</a>
by Sebastien Deleuze.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-reactive-feature-overview" href="#web-reactive-feature-overview"></a>23.2&nbsp;Spring Web Reactive Overview</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-module" href="#web-reactive-module"></a>23.2.1&nbsp;Spring Web Reactive Module</h3></div></div></div>

<p>Spring Framework 5 adds a new <code class="literal">spring-web-reactive</code> module that supports the same
<code class="literal">@Controller</code> programming model as Spring MVC but executed on a reactive,
non-blocking engine. The diagram below shows how Spring MVC and Spring Web
Reactive compare side by side:</p>
<div class="informalfigure">
<div class="mediaobject"><img src="images/web-reactive-overview.png" alt="web reactive overview"></div>
</div>
<p>Spring Web Reactive makes use of Servlet 3.1 non-blocking I/O and runs on
Servlet 3.1 containers. It also runs on non-Servlet runtimes such as Netty and Undertow.
Each runtime is adapted to a set of shared, reactive <code class="literal">ServerHttpRequest</code> and
<code class="literal">ServerHttpResponse</code> abstractions that expose the request and response body
as <code class="literal">Flux&lt;DataBuffer&gt;</code> with full backpressure support on the read and the
write side.</p>
<p>The <code class="literal">spring-core</code> module provides reactive <code class="literal">Encoder</code> and <code class="literal">Decoder</code> contracts
that enable the serialization of a <code class="literal">Flux</code> of bytes to and from typed objects.
The <code class="literal">spring-web</code> module adds JSON (Jackson) and XML (JAXB) implementations for use in
web applications as well as others for SSE streaming and zero-copy file transfer.</p>
<p>The <code class="literal">spring-web-reactive</code> module contains the Spring Web Reactive framework that supports
the <code class="literal">@Controller</code> programming model. It re-defines many of the Spring MVC contracts
such as <code class="literal">HandlerMapping</code> and <code class="literal">HandlerAdapter</code> to be asynchronous and
non-blocking and to operate on the reactive HTTP request and response. For this reason
Spring MVC and Spring Web Reactive cannot share any code. However they do share
many of the same algorithms.</p>
<p>The end result is a programming model identical to today&#8217;s Spring MVC but
with support for reactive types and executed in a reactive manner.
For example a controller method can declare a <code class="literal">@RequestBody</code> method argument
in any one of the following ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">Account account</code>&#8201;&#8212;&#8201;the account is deserialized without
blocking before the controller is invoked.
</li><li class="listitem">
<code class="literal">Mono&lt;Account&gt; account</code>&#8201;&#8212;&#8201;the controller can use the <code class="literal">Mono</code>
to declare logic to be executed after the account is deserialized.
</li><li class="listitem">
<code class="literal">Single&lt;Account&gt; account</code>&#8201;&#8212;&#8201;same as with <code class="literal">Mono</code> but using RxJava
</li><li class="listitem">
<code class="literal">Flux&lt;Account&gt; accounts</code>&#8201;&#8212;&#8201;input streaming scenario.
</li><li class="listitem">
<code class="literal">Observable&lt;Account&gt; accounts</code>&#8201;&#8212;&#8201;input streaming with RxJava.
</li></ul></div>
<p>Similarly a controller can also an <code class="literal">@ResponseBody</code> return value
in any one of the following ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">Mono&lt;Account&gt;</code>&#8201;&#8212;&#8201;serialize without blocking the given Account when the <code class="literal">Mono</code> completes.
</li><li class="listitem">
<code class="literal">Single&lt;Account&gt;</code>&#8201;&#8212;&#8201;same but using RxJava.
</li><li class="listitem">
<code class="literal">Flux&lt;Account&gt;</code>&#8201;&#8212;&#8201;streaming scenario, possibly SSE depending on the requested content type.
</li><li class="listitem">
<code class="literal">Observable&lt;Account&gt;</code>&#8201;&#8212;&#8201;same but using RxJava <code class="literal">Observable</code> type.
</li><li class="listitem">
<code class="literal">Flowable&lt;Account&gt;</code>&#8201;&#8212;&#8201;same but using RxJava 2 <code class="literal">Flowable</code> type.
</li><li class="listitem">
<code class="literal">Flux&lt;ServerSentEvent&gt;</code>&#8201;&#8212;&#8201;SSE streaming.
</li><li class="listitem">
<code class="literal">Mono&lt;Void&gt;</code>&#8201;&#8212;&#8201;request handling completes when the <code class="literal">Mono</code> completes.
</li><li class="listitem">
<code class="literal">void</code>&#8201;&#8212;&#8201;request handling completes when the method returns;
implies a synchronous, non-blocking controller method.
</li><li class="listitem">
<code class="literal">Account</code>&#8201;&#8212;&#8201;serialize without blocking the given Account;
implies a synchronous, non-blocking controller method.
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-client" href="#web-reactive-client"></a>23.2.2&nbsp;Reactive Web Client</h3></div></div></div>

<p>Spring Framework 5 adds a new reactive <code class="literal">WebClient</code> in addition to the existing <code class="literal">RestTemplate</code>.</p>
<p>A <code class="literal">WebClient</code> instance use a <code class="literal">ClientHttpConnector</code> implementation to drive the underlying
supported HTTP client (e.g. Reactor Netty). This client is adapted to a set of shared,
reactive <code class="literal">ClientHttpRequest</code> and <code class="literal">ClientHttpResponse</code> abstractions that expose the request
and response body as <code class="literal">Flux&lt;DataBuffer&gt;</code> with full backpressure support on the read and
the write side. The <code class="literal">HttpMessageReader</code> and <code class="literal">HttpMessageWriter</code> abstractions are also used on
the client side for the serialization of a <code class="literal">Flux</code> of bytes to and from typed objects.</p>
<p>An example of using the <code class="literal">WebClient</code>:</p>
<pre class="programlisting"><span class="hl-comment">// create an immutable instance of WebClient</span>
WebClient webClient = WebClient.create(<span class="hl-keyword">new</span> ReactorClientHttpConnector());

ClientRequest&lt;Void&gt; request = ClientRequest.GET(<span class="hl-string">"http://example.com/accounts/{id}"</span>, <span class="hl-number">1L</span>)
				.accept(MediaType.APPLICATION_JSON).build();

Mono&lt;Account&gt; account = <span class="hl-keyword">this</span>.webClient
				.exchange(request)
				.then(response -&gt; response.body(toMono(Account.<span class="hl-keyword">class</span>)));</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-reactive-getting-started" href="#web-reactive-getting-started"></a>23.3&nbsp;Getting Started</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-getting-started-boot" href="#web-reactive-getting-started-boot"></a>23.3.1&nbsp;Spring Boot Starter</h3></div></div></div>

<p>The
<a class="ulink" href="https://github.com/bclozel/spring-boot-web-reactive#spring-boot-web-reactive-starter" target="_top">Spring Boot Web Reactive starter</a>
available via <a class="ulink" href="http://start.spring.io" target="_top">http://start.spring.io</a>
is the fastest way to get started. It does all that&#8217;s necessary so you can start
writing <code class="literal">@Controller</code> classes. By default it runs on Tomcat but the dependencies can
be changed as usual with Spring Boot to switch to a different runtime.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-getting-started-manual" href="#web-reactive-getting-started-manual"></a>23.3.2&nbsp;Manual Bootstrapping</h3></div></div></div>

<p>This section outlines the steps to get up and running without Spring Boot.</p>
<p>For dependencies start with <code class="literal">spring-web-reactive</code> and <code class="literal">spring-context</code>.
Then add <code class="literal">jackson-databind</code> and <code class="literal">io.netty:netty-buffer:4.1.3.Final</code>
(temporarily see <a class="ulink" href="https://jira.spring.io/browse/SPR-14528" target="_top">SPR-14528</a>) for JSON support.
Lastly add the dependencies for one of the supported runtimes:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Tomcat&#8201;&#8212;&#8201;<code class="literal">org.apache.tomcat.embed:tomcat-embed-core</code>
</li><li class="listitem">
Jetty&#8201;&#8212;&#8201;<code class="literal">org.eclipse.jetty:jetty-server</code> and <code class="literal">org.eclipse.jetty:jetty-servlet</code>
</li><li class="listitem">
Reactor Netty&#8201;&#8212;&#8201;<code class="literal">io.projectreactor.ipc:reactor-netty</code>
</li><li class="listitem">
RxNetty&#8201;&#8212;&#8201;<code class="literal">io.reactivex:rxnetty-common</code> and <code class="literal">io.reactivex:rxnetty-http</code>
</li><li class="listitem">
Undertow&#8201;&#8212;&#8201;<code class="literal">io.undertow:undertow-core</code>
</li></ul></div>
<p>For the bootstrap code start with:</p>
<pre class="programlisting">ApplicationContext context = <span class="hl-keyword">new</span> AnnotationConfigApplicationContext(DelegatingWebReactiveConfiguration.<span class="hl-keyword">class</span>);  <span class="hl-comment">// (1)</span>
HttpHandler handler = DispatcherHandler.toHttpHandler(context);  <span class="hl-comment">// (2)</span></pre>
<p>The above loads default Spring Web Reactive config (1), then creates a
<code class="literal">DispatcherHandler</code>, the main class driving request processing (2), and adapts
it to <code class="literal">HttpHandler</code>, the lowest level Spring abstraction for reactive HTTP request handling.
An <code class="literal">HttpHandler</code> can then be installed in each supported runtime:</p>
<pre class="programlisting"><span class="hl-comment">// Tomcat and Jetty (also see notes below)</span>
HttpServlet servlet = <span class="hl-keyword">new</span> ServletHttpHandlerAdapter(handler);
...

<span class="hl-comment">// Reactor Netty</span>
ReactorHttpHandlerAdapter adapter = <span class="hl-keyword">new</span> ReactorHttpHandlerAdapter(handler);
HttpServer server = HttpServer.create(host, port);
server.startAndAwait(adapter);

<span class="hl-comment">// RxNetty</span>
RxNettyHttpHandlerAdapter adapter = <span class="hl-keyword">new</span> RxNettyHttpHandlerAdapter(handler);
HttpServer server = HttpServer.newServer(<span class="hl-keyword">new</span> InetSocketAddress(host, port));
server.startAndAwait(adapter);

<span class="hl-comment">// Undertow</span>
UndertowHttpHandlerAdapter adapter = <span class="hl-keyword">new</span> UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For Servlet runtimes you can use the <code class="literal">AbstractAnnotationConfigDispatcherHandlerInitializer</code>,
which as a <code class="literal">WebApplicationInitializer</code> is auto-detected by Servlet containers
and it registers for you the <code class="literal">ServletHttpHandlerAdapter</code> shown above.
Only implement one method to point to your Spring Java configuration classes.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-reactive-getting-started-M1" href="#web-reactive-getting-started-M1"></a>23.3.3&nbsp;Extent of Support in 5.0 M1</h3></div></div></div>

<p>For M1 the Spring Web Reactive module focuses on REST scenarios for both
client and server. Basic HTML rendering with Freemarker is also supported but
limited to rendering but not form submissions.</p>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="websocket.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-web.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-integration.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">22.&nbsp;WebSocket Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;VI.&nbsp;Integration</td></tr></table></div></body></html>